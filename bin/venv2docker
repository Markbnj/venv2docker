#!/bin/bash

# venv2docker is a script to migrate a virtualenv python environment
# into a docker container. Note that it migrates only the python
# environment and installed dependencies.

version="0.0.1"
venv_root="${HOME}/.virtualenvs/"

# display help for the 'make' subcommand
help_make() {
    echo "COMMAND: make"
    echo
    echo "venv2docker make [OPTION]... [VIRTUALENV]"
    echo
    echo "Create a new docker image from an existing virtualenv"
    echo "Example:"
    echo "    venv2docker make --name=myrepo/test testenv"
    echo
    echo "Creates a docker image from the 'testenv' virtualenv and commits"
    echo "it to myrepo/test."
    echo
    echo "If the -p/--push argument is supplied then REPO must also be specified."
    echo
    echo "Options:"
    printf "\t--apt=PACKAGES\t\t\tUse apt-get to install PACKAGES at build.\n"
    printf "\t--apt=FILE\t\t\t\tInstall each package in FILE at build.\n"
    printf "\t-a,--args=ARGS\t\t\tPass ARGS to entrypoint command line.\n"
    printf "\t-b,--base=BASE\t\t\tUse BASE as the base image.\n"
    printf "\t-c,--command=COMMAND\tExecute COMMAND as entrypoint at startup.\n"
    printf "\t--dockerdir=DIR\t\t\tUse DIR for build files (defaults to .docker).\n"
    printf "\t-e,--env=ENV\t\t\tSet variables in ENV inside image.\n"
    printf "\t-i,--installdir=DIR\t\tInstall the project folder to DIR in the image.\n"
    printf "\t--maintainer=NAME\t\tUse NAME as the maintainer string in the image.\n"
    printf "\t-n,--name=NAME\t\t\tUse NAME as the committed image name.\n"
    printf "\t-p,--push\t\t\t\tPush the image to the Docker hub after building.\n"
    printf "\t--ports=PORTS\t\t\tExpose PORTS in image.\n"
    printf "\t--pypaths=PATHS\t\t\tAdd relative or absolute PATHS to python path.\n"
    printf "\t-r,--run\t\t\t\tLaunch the image after building.\n"
    printf "\t-s,--skip-image\t\t\tGenerate the dockerfile but skip building.\n"
    printf "\t-t,--tag=TAG\t\t\tUse TAG as the tag for the built image."
    echo
    echo "More examples:"
    echo
    echo "1)  venv2docker make --push --base=ubuntu:15.10 --command=app.py \\"
    echo "        --name=testrepo/test:latest --args='1,--foo=blah,--bar=@var'"
    echo
    echo "    Creates an image from the currently active virtual env, using ubuntu 15.10"
    echo "    as the base image, setting 'start.sh' as the startup command, with the"
    echo "    following command line:"
    echo
    echo "        start.sh 1 --foo=blah --bar=\${var}"
    echo
    echo "    The image will be committed as testrepo/test:latest and pushed to the docker"
    echo "    hub if the build succeeds."
    echo
    echo
    echo "2)  venv2docker make --base=debian:jessie --ports='80,443' \\"
    echo "        --name=testrepo/app:latest --env='var=1,var1=2' foobar"
    echo
    echo "    Creates an image from the foobar virtualenv using debian:jessie as the"
    echo "    base image, exposing ports 80 and 443, and setting the environment variables"
    echo "    'var' and 'var2' to 1 and 2 respectively, inside the image."
}

# display help for the 'run' subcommand
help_run() {
    echo "COMMAND: run"
    echo
    echo "venv2docker run [[REPO/]IMAGE_NAME[:TAG]]"
    echo
    echo "Run an existing virtualenv docker image"
    echo "Example:"
    echo "    venv2docker run myrepo/test"
    echo
    echo "Runs the specified docker image and opens an interactive shell in it."
    echo
    echo "Options:"
    printf "\tNone\n"
}

# display help for the 'remove' subcommand
help_remove() {
    echo "COMMAND: remove"
    echo
    echo "venv2docker remove [[REPO/]IMAGE_NAME[:TAG]]"
    echo
    echo "Remove an existing virtualenv docker image"
    echo "Example:"
    echo "    venv2docker remove myrepo/test"
    echo
    echo "Removes the specified virtualenv docker image."
    echo
    echo "Options:"
    printf "\tNone\n"
}

# display the main help screen, if a command name is passed include specific help
# for that command
show_help() {
    echo "venv2docker ${version}"
    echo
    echo "USAGE: venv2docker COMMAND [OPTION]... [VIRTUALENV] [[REPO/]IMAGE_NAME[:TAG]]"
    echo
    echo "Create, run, and deploy docker images built from an existing virtualenv"
    echo "environment."
    echo
    echo "If VIRTUALENV is not supplied and a virtualenv is currently active"
    echo "then that venv will be migrated."
    echo
    echo "If IMAGE_NAME is not supplied then the name of the virtualenv will be used for"
    echo "the image name."
    echo
    if [ ! -z "$2" ]; then
        case $2 in
            "make"|"mk")
                help_make
                ;;
            "run")
                help_run
                ;;
            "remove"|"rm")
                help_remove
                ;;
            *)
                echo "No help available for command: ${2}."
                exit 1
                ;;
        esac
    else
        echo "COMMANDS: make, run, remove"
        echo
        echo "For help on a specific command use 'venv2docker help <command>'"
    fi
    echo
    exit $1
}

# check to make sure the docker command is available, display an
# error and exit if it is not.
ensure_docker() {
    docker=$(which docker)
    if [ -z "${docker}" ]; then
        echo "Error: 'docker' command not found."
        echo "This program requires docker to be installed locally."
        echo "See https://docs.docker.com/linux/step_one/ for more information."
        exit 1
    fi
}

# check to be sure we were passed a valid venv, otherwise detect
# the current active venv, set venv to the full path to the environment
make_ensure_venv() {
    target_venv="$venv"
    if [ ! -z "${target_venv}" ]; then
        path="${venv_root}${target_venv}"
        if [ -d "${path}" ]; then
            venv=$path
        else
            echo "Error: virtual env '${target_venv}' not found at ${venv_root}"
            exit 1
        fi
    else
        if [ -z "${VIRTUAL_ENV}" ]; then
            echo "Error: virtual env not specified and no active virtual environment"
            echo "found."
            echo
            show_help 1
        else
            venv=$VIRTUAL_ENV
        fi
    fi
}

make_clean_build() {
    # TBD look for and clean out any orphaned temps
    echo "Running clean on ${projectpath}/${dockerdir} ..."
    if [ -f "${projectpath}/${dockerdir}/*.gz" ]; then
        echo "Removing archive files ..."
        if $(rm ${projectpath}/${dockerdir}/*.gz); then
            echo "Archive files removed"
        else
            echo "Error: failed to remove files from ${projectpath}/${dockerdir}; check file and directory permissions"
            exit 1
        fi
    fi
}

# stage the project directories to tmp, create the docker directory, and then
# pack the project and system files into the docker directory.
make_setup_build() {
    # stage the project files in tmp
    tmpdir=$(mktemp -d)
    mkdir ${tmpdir}/${projectdir}
    echo "Staging ${projectpath} to ${tmpdir} ..."
    if $(cp -R ${projectpath}/* ${tmpdir}/${projectdir}); then
        echo "${projectpath} complete"
    else
        echo "Error: failed to copy ${projectpath} to ${tmpdir}/${projectdir}; check directory and file permissions."
        exit 1
    fi

    # create the build folder if we don't have it, otherwise run
    # clean on it
    if [ ! -d "${projectpath}/${dockerdir}" ]; then
        echo "Creating build directory ..."
        mkdir ${projectpath}/${dockerdir}
    else
        make_clean_build
    fi

    echo "Packing project files ..."
    if $(tar cfP - ${tmpdir}/${projectdir} | gzip > ${projectpath}/${dockerdir}/${projectdir}.tar.gz); then
        echo "${tmpdir}/${projectdir} complete"
    else
        echo "Error: failed to pack ${tmpdir}/${projectdir}; check directory and file permissions."
        exit 1
    fi

    echo "Removing temporary files ..."
    if $(rm -rf ${tmpdir}/${projectdir}); then
        echo "Temporary files in ${tmpdir}/${projectdir} removed"
    else
        echo "Warning: unable to remove staging folder ${tmpdir}/${projectdir}"
    fi

    echo "Packing system files ..."
    if $(tar cfP - ${venv}/bin | gzip > ${projectpath}/${dockerdir}/venv_bin.tar.gz); then
        echo "${venv}/bin complete"
    else
        echo "Error: failed to pack ${venv}/bin; check directory and file permissions."
        exit 1
    fi

    if $(tar cfP - ${venv}/lib | gzip > ${projectpath}/${dockerdir}/venv_lib.tar.gz); then
        echo "${venv}/lib complete"
    else
        echo "Error: failed to pack ${venv}/lib; check directory and file permissions."
        exit 1
    fi

    if $(tar cfP - ${venv}/local/lib | gzip > ${projectpath}/${dockerdir}/venv_local_lib.tar.gz); then
        echo "${venv}/local/lib complete"
    else
        echo "Error: failed to pack ${venv}/local/lib; check directory and file permissions."
        exit 1
    fi
    echo "System files completed"
}

# implements the 'make' subcommand
make_image() {
    local image_name=
    local tag="latest"
    local venv=
    local projectpath=
    local projectdir=
    local base="debian:jessie"
    local entrypoint="/bin/bash"
    local no_image=false
    local push_image=false
    local run_image=false
    local args=
    local ports=
    local envs=
    local dockerdir=".docker"
    local dockerfile=
    local maintainer=
    local installdir="/usr/local/bin/"
    local apt=
    local pypaths=

    # parse out the options
    OPTS=$(getopt -o a:b:c:e:i:n:prst: --long apt:,args:,base:,command:,dockerdir:,env:,installdir:,maintainer:,name:,ports:,push,pypaths:,skip-image,tag: -- "$@")
    if [[ $? -ne 0 ]]; then
        echo "Error: failed to parse command line options."
        exit 1
    fi

    eval set -- "$OPTS"
    while true; do
        case "$1" in
            --apt)
                apt="$2"
                shift; shift
                ;;
            -a|--args)
                args="$2"
                shift; shift
                ;;
            -b|--base)
                base="$2"
                shift; shift
                ;;
            -c|--command)
                entrypoint="$2"
                shift; shift
                ;;
            --dockerdir)
                dockerdir="$2"
                shift; shift
                ;;
            -e|--env)
                envs="$2"
                shift; shift
                ;;
            -i|--installdir)
                installdir="$2"
                shift; shift
                ;;
            --maintainer)
                maintainer="$2"
                shift; shift
                ;;
            -n|--name)
                image_name="$2"
                shift; shift
                ;;
            --ports)
                ports="$2"
                shift; shift
                ;;
            -p|--push)
                push_image=true
                shift
                ;;
            --pypaths)
                pypaths="$2"
                shift; shift
                ;;
            -r|--run)
                run_image=true
                shift
                ;;
            -s|--skip-image)
                no_image=true
                shift
                ;;
            -t|--tag)
                tag="$2"
                shift; shift
                ;;
            --)
                shift
                if [ ! -z "$1" ]; then
                    venv="$1"
                fi
                break
                ;;
            *)
                echo "Error: unknown option '${1}'"
                help 1
                ;;
        esac
    done

    ensure_docker
    make_ensure_venv

    # get the project directory from the virtualenv
    projectpath=$(cat ${venv}/.project)
    if [ -z "${projectpath}" ]; then
        echo "Error: could not find project home for env $venv"
        exit 1
    fi
    path_split=($(echo ${projectpath} | tr "/" "\n"))
    projectdir=${path_split[ ${#path_split[@]} -1 ]}
    unset path_split

    # ensure that the image name is set to something reasonable
    if [ -z "${image_name}" ]; then
        venv_split=($(echo ${venv} | tr "/" "\n"))
        image_name=${venv_split[ ${#venv_split[@]} -1 ]}
        unset venv_split
    fi

    make_setup_build



    # generate the dockerfile (add commands and path setting)
    # copy the dependencies into the context
    # execute the build command
    # remove the dependencies

    echo "DEBUG ============================="
    echo "image name: ${image_name}"
    echo "tag: ${tag}"
    echo "venv: ${venv}"
    echo "projectpath: ${projectpath}"
    echo "projectdir: ${projectdir}"
    echo "base: ${base}"
    echo "entrypoint: ${entrypoint}"
    echo "no_image: ${no_image}"
    echo "push_image: ${push_image}"
    echo "run_image: ${run_image}"
    echo "args: ${args}"
    echo "ports: ${ports}"
    echo "envs: ${envs}"
    echo "dockerdir: ${dockerdir}"
    echo "maintainer: ${maintainer}"
    echo "installdir: ${installdir}"
    echo "apt: ${apt}"
    echo "pypaths: ${pypaths}"
    echo "==================================="
    echo
}

run_image() {
    echo "$@"
}

remove_image() {
    echo "$@"
}

# set tabs = 4
tabs 4

# the first argument must be the command to execute
case $1 in
    "make"|"mk")
        make_image "${@:2}"
        ;;
    "run")
        run_image "${@:2}"
        ;;
    "remove"|"rm")
        remove_image "${@:2}"
        ;;
    "help"|"-h"|"--help")
        show_help 0 $2
        ;;
    *)
        echo "Error: missing or malformed command name."
        echo
        help 1
esac
