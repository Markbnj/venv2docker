#!/bin/bash

# venv2docker is a script to migrate a virtualenv python environment
# into a docker container. Note that it migrates only the python
# environment and installed dependencies.

version="0.0.1"
venv_root="${VIRTUALENVWRAPPER_HOOK_DIR}/"
image_name=
tag="latest"
venv=
projectpath=
projectdir=
base="debian:jessie"
entrypoint=
no_image=false
push_image=false
run_image=false
rem_old_image=false
debug=false
log_build=true
log_name="build.log"
args=
ports=
envs=
dockerdir=".venv2docker"
dockerfile=
maintainer=
bin_path="/usr/local/bin/"
lib_path="/usr/local/lib/"
apt=
pip=
pypaths=
paths=
cwd=$(pwd)
sys_paths=()
python_paths=()
clean_only=false
user=
workdir=

# display the main help screen, if a command name is passed include specific help
# for that command
show_help() {
    echo "venv2docker ${version}"
    echo
    echo "USAGE: venv2docker [OPTION]... [VIRTUALENV]"
    echo
    echo "Create docker images built from an existing virtualenv environment."
    echo
    echo "If VIRTUALENV is not supplied and a virtualenv is currently active"
    echo "then that venv will be used."
    echo
    echo "Example:"
    echo "    venv2docker --name=myrepo/test testenv"
    echo
    echo "Creates a docker image from the 'testenv' virtualenv and commits"
    echo "it to myrepo/test."
    echo
    echo "Options:"
    printf "\t--apt=PACKAGES\t\t\tUse apt-get to install PACKAGES at build.\n"
    printf "\t--apt=FILE\t\t\t\tInstall each package in FILE at build.\n"
    printf "\t--args=ARGS\t\t\t\tPass ARGS to entrypoint command line.\n"
    printf "\t-b, --base=BASE\t\t\tUse BASE as the base image.\n"
    printf "\t--bin_path=PATH\t\t\tInstall the project folder to PATH in the image.\n"
    printf "\t-c, --clean\t\t\t\tPerform build clean step and exit\n."
    printf "\t-d, --debug\t\t\t\tPrint diagnostic information after build.\n"
    printf "\t--dockerdir=DIR\t\t\tUse DIR for build files (defaults to .venv2docker).\n"
    printf "\t--entrypoint=COMMAND\tExecute COMMAND as entrypoint at startup.\n"
    printf "\t-e, --env=ENV\t\t\tSet variables in ENV inside image.\n"
    printf "\t--lib_path=PATH\t\t\tInstall the venv directories to PATH in the image.\n"
    printf "\t--maintainer=NAME\t\tUse NAME as the maintainer string in the image.\n"
    printf "\t-n, --name=NAME\t\t\tUse NAME as the committed image name.\n"
    printf "\t--no-dangling\t\t\tRemove an existing image before building.\n"
    printf "\t--no-log\t\t\t\tDon't log docker build output.\n"
    printf "\t--paths=PATHS\t\t\tAdd PATHS to system path.\n"
    printf "\t--pip=FILE\t\t\t\tInstall each package in FILE at build.\n"
    printf "\t--ports=PORTS\t\t\tExpose PORTS in image.\n"
    printf "\t-p, --push\t\t\t\tPush the image to the Docker hub after building.\n"
    printf "\t--pypaths=PATHS\t\t\tAdd PATHS to python path.\n"
    printf "\t-r, --run\t\t\t\tLaunch the image after building.\n"
    printf "\t-s, --skip-image\t\tGenerate the dockerfile but skip building.\n"
    printf "\t-t, --tag=TAG\t\t\tUse TAG as the tag for the built image.\n"
    printf "\t-u, --user=USER\t\t\tChange to USER before running entrypoint.\n"
    printf "\t-w, --workdir=DIR\t\tChange to DIR before running entrypoint.\n"
    echo
    echo "More examples:"
    echo
    echo "1)  venv2docker --push --base=ubuntu:15.10 --command=app.py \\"
    echo "        --name=testrepo/test:latest --args='1,--foo=blah,--bar=$var'"
    echo
    echo "    Creates an image from the currently active virtual env, using ubuntu 15.10"
    echo "    as the base image, setting 'start.sh' as the startup command, with the"
    echo "    following command line:"
    echo
    echo "        start.sh 1 --foo=blah --bar=\${var}"
    echo
    echo "    The image will be committed as testrepo/test:latest and pushed to the docker"
    echo "    hub if the build succeeds."
    echo
    echo
    echo "2)  venv2docker --base=debian:jessie --ports=80,443 \\"
    echo "        --name=testrepo/app:latest --env='var=1,var1=2' foobar"
    echo
    echo "    Creates an image from the foobar virtualenv using debian:jessie as the"
    echo "    base image, exposing ports 80 and 443, and setting the environment variables"
    echo "    'var' and 'var2' to 1 and 2 respectively, inside the image."
    echo
    if [ ! -z "${1}" ]; then
        exit $1
    else
        exit 0
    fi
}

# check to make sure the docker command is available, display an
# error and exit if it is not.
ensure_docker() {
    docker=$(which docker)
    if [ -z "${docker}" ]; then
        echo "Error: 'docker' command not found."
        echo "This program requires docker to be installed locally."
        echo "See https://docs.docker.com/linux/step_one/ for more information."
        exit 1
    fi
}

# check to be sure we were passed a valid venv, otherwise detect
# the current active venv, set venv to the full path to the environment
ensure_venv() {
    if [ ! -z "${venv}" ]; then
        if [ ! -d "${venv_root}${venv}" ]; then
            echo "Error: virtual env '${venv}' not found at ${venv_root}"
            exit 1
        fi
    else
        if [ -z "${VIRTUAL_ENV}" ]; then
            echo "Error: virtual env not specified and no active virtual environment"
            echo "found."
            echo
            show_help 1
        else
            venv=$(basename ${VIRTUAL_ENV})
        fi
    fi
    # get the project directory from the virtualenv
    projectpath=$(cat ${venv_root}${venv}/${VIRTUALENVWRAPPER_PROJECT_FILENAME})
    if [ -z "${projectpath}" ]; then
        echo "Error: could not find project home for env $venv"
        exit 1
    fi
    projectdir=$(basename ${projectpath})
}

# if the docker build directory already exists get rid of anything
# we're going to recreate on this run.
clean_build() {
    echo "Running clean on ${projectpath}/${dockerdir} ..."
    if [ -f "${projectpath}/${dockerdir}/${projectdir}.tar.gz" ]; then
        echo "Removing ${projectpath}/${dockerdir}/${projectdir}.tar.gz ..."
        if $(rm ${projectpath}/${dockerdir}/${projectdir}.tar.gz); then
            echo "${projectpath}/${dockerdir}/${projectdir}.tar.gz removed"
        else
            echo "Error: failed to remove ${projectpath}/${dockerdir}/${projectdir}.tar.gz; check file and directory permissions"
            exit 1
        fi
    fi
    if [ -f "${projectpath}/${dockerdir}/venv_bin.tar.gz" ]; then
        echo "Removing ${projectpath}/${dockerdir}/venv_bin.tar.gz ..."
        if $(rm ${projectpath}/${dockerdir}/venv_bin.tar.gz); then
            echo "${projectpath}/${dockerdir}/venv_bin.tar.gz removed"
        else
            echo "Error: failed to remove ${projectpath}/${dockerdir}/venv_bin.tar.gz; check file and directory permissions"
            exit 1
        fi
    fi
    if [ -f "${projectpath}/${dockerdir}/venv_include.tar.gz" ]; then
        echo "Removing ${projectpath}/${dockerdir}/venv_include.tar.gz ..."
        if $(rm ${projectpath}/${dockerdir}/venv_include.tar.gz); then
            echo "${projectpath}/${dockerdir}/venv_include.tar.gz removed"
        else
            echo "Error: failed to remove ${projectpath}/${dockerdir}/venv_include.tar.gz; check file and directory permissions"
            exit 1
        fi
    fi
    if [ -f "${projectpath}/${dockerdir}/venv_lib.tar.gz" ]; then
        echo "Removing ${projectpath}/${dockerdir}/venv_lib.tar.gz ..."
        if $(rm ${projectpath}/${dockerdir}/venv_lib.tar.gz); then
            echo "${projectpath}/${dockerdir}/venv_lib.tar.gz removed"
        else
            echo "Error: failed to remove ${projectpath}/${dockerdir}/venv_lib.tar.gz; check file and directory permissions"
            exit 1
        fi
    fi
    if [ -f "${projectpath}/${dockerdir}/venv_local_lib.tar.gz" ]; then
        echo "Removing ${projectpath}/${dockerdir}/venv_local_lib.tar.gz ..."
        if $(rm ${projectpath}/${dockerdir}/venv_local_lib.tar.gz); then
            echo "${projectpath}/${dockerdir}/venv_local_lib.tar.gz removed"
        else
            echo "Error: failed to remove ${projectpath}/${dockerdir}/venv_local_lib.tar.gz; check file and directory permissions"
            exit 1
        fi
    fi
    if [ -f "${projectpath}/${dockerdir}/requirements.txt" ]; then
        echo "Removing pip requirements file ..."
        if $(rm ${projectpath}/${dockerdir}/requirements.txt); then
            echo "pip requirements file removed"
        else
            echo "Error: failed to remove ${projectpath}/${dockerdir}/requirements.txt; check file and directory permissions"
            exit 1
        fi
    fi
    if [ -f "${projectpath}/${dockerdir}/build.log" ]; then
        echo "Removing old build log ..."
        if $(rm ${projectpath}/${dockerdir}/build.log); then
            echo "build log removed"
        else
            echo "Error: failed to remove ${projectpath}/${dockerdir}/build.log; check file and directory permissions"
            exit 1
        fi
    fi
    if [ -f "${projectpath}/${dockerdir}/Dockerfile" ]; then
        echo "Removing old dockerfile ..."
        if $(rm ${projectpath}/${dockerdir}/Dockerfile); then
            echo "dockerfile removed"
        else
            echo "Error: failed to remove ${projectpath}/${dockerdir}/Dockerfile; check file and directory permissions"
            exit 1
        fi
    fi
    if [ -d "${projectpath}/${dockerdir}" ]; then
        echo "Removing build directory ..."
        if $(rmdir ${projectpath}/${dockerdir}); then
            echo "Build directory removed"
        else
            echo "Warning: failed to remove ${projectpath}/${dockerdir}; directory may not be empty"
        fi
    fi
}

# expects a directory path in $1, patches any text file in the
# directory and subdirectories that contains the hard-coded
# virtualenv interpreter path
patch_paths() {
    echo "Not yet"
}

# expects a directory path in $1, folder name in $2, tmp dir name in
# $3, archive name in $4, stages the folder in temp, patches the paths, and
# then zips it into the build directory.
process_venv_directory() {
    local base_dir=${1}
    local venv_dir=${2}
    local tmp_dir=${3}
    local zip_name=${4}

    echo "Staging ${base_dir}${venv_dir} to ${tmp_dir} ..."
    if $( tar -c --directory=${base_dir} ./${venv_dir} --exclude=*.pyc | tar -x --directory=${tmp_dir} ); then
        patch_paths ${tmp_dir}/${venv_dir}
        echo "Packing ${tmp_dir}/${venv_dir} to ${projectpath}/${dockerdir} ..."
        if $(tar -c --directory=${tmp_dir} ./${venv_dir} | gzip > ${projectpath}/${dockerdir}/${zip_name}.tar.gz); then
            echo "${base_dir}${venv_dir} complete"
            echo "Removing temporary files ..."
            if $(rm -rf ${tmp_dir}/${venv_dir}); then
                echo "Temporary files in ${tmp_dir}/${venv_dir} removed"
            else
                echo "Warning: unable to remove staging folder ${tmp_dir}/${venv_dir}"
            fi
        else
            echo "Error: failed to pack ${tmp_dir}/${venv_dir}; check directory and file permissions."
            exit 1
        fi
    else
        echo "Error: failed to copy ${base_dir}/${venv_dir} to ${tmp_dir}; check directory and file permissions."
        exit 1
    fi
}

# stage the project directories to tmp, create the docker directory, and then
# pack the project and system files into the docker directory.
setup_build() {
    tmpdir=$(mktemp -d)

    # if the build folder exists clean it out, this may remove the folder
    # but will not if the user has copied anything to it, so we still
    # use --exclude on the tar command below
    if [ -d "${projectpath}/${dockerdir}" ]; then
        clean_build
    fi

    # stage the project files in tmp - we check for the project path because
    # its at least possible it might not exist, and that all the user wants
    # is the virtualenv
    if [ -d "${projectpath}" ]; then
        echo "Staging ${projectpath} to ${tmpdir} ..."
        if $( tar -c --directory=${projectpath} ../${projectdir} --exclude=*.pyc --exclude=./${projectdir}/${dockerdir} | tar -x --directory=${tmpdir} ); then
            echo "${projectpath} complete"
        else
            echo "Error: failed to copy ${projectpath} to ${tmpdir}; check directory and file permissions."
            exit 1
        fi
    else
        echo "Warning: ${projectpath} not found; skipping"
    fi

    # create the build folder if we don't have it
    if [ ! -d "${projectpath}/${dockerdir}" ]; then
        echo "Creating build directory ..."
        mkdir ${projectpath}/${dockerdir}
    fi

    # if we didn't skip the project files above then this path exists, so pack it
    # into the build folder
    if [ -d "${tmpdir}/${projectdir}" ]; then
        echo "Packing project files ..."
        if $(tar -c --directory=${tmpdir} ./${projectdir} | gzip > ${projectpath}/${dockerdir}/${projectdir}.tar.gz); then
            echo "${tmpdir}/${projectdir} complete"
        else
            echo "Error: failed to pack ${tmpdir}/${projectdir}; check directory and file permissions."
            exit 1
        fi
        echo "Removing temporary files ..."
        if $(rm -rf ${tmpdir}/${projectdir}); then
            echo "Temporary files in ${tmpdir}/${projectdir} removed"
        else
            echo "Warning: unable to remove staging folder ${tmpdir}/${projectdir}"
        fi
    fi

    echo "Packing system files ..."

    if [ -d "${venv_root}${venv}/bin" ]; then
        process_venv_directory ${venv_root} ${venv}/bin ${tmpdir} venv_bin
    else
        echo "Warning: ${venv_root}${venv}/bin not found; skipping"
    fi

    if [ -d "${venv_root}${venv}/include" ]; then
        process_venv_directory ${venv_root} ${venv}/include ${tmpdir} venv_include
    else
        echo "Warning: ${venv_root}${venv}/include not found; skipping"
    fi

    if [ -d "${venv_root}${venv}/lib" ]; then
        process_venv_directory ${venv_root} ${venv}/lib ${tmpdir} venv_lib
    else
        echo "Warning: ${venv_root}${venv}/lib not found; skipping"
    fi

    if [ -d "${venv_root}${venv}/local/lib" ]; then
        process_venv_directory ${venv_root} ${venv}/local/lib ${tmpdir} venv_local_lib
    else
        echo "Warning: ${venv_root}${venv}/local/lib not found; skipping"
    fi

    echo "Removing temporary directory ..."
    rm -rf ${tmpdir}
    echo "System files completed"
}

emit_dockerfile_header() {
    echo "Generating header ..."
    dockerfile=("#")
    dockerfile+=("# generated on: $(date)")
    dockerfile+=("#")
    dockerfile+=("# project path: ${projectpath}")
    dockerfile+=("# venv path: ${venv}")
    dockerfile+=("# image name: ${image_name}")
    dockerfile+=("# script version: ${version}")
    dockerfile+=("#")
    dockerfile+=("# This file will be recreated if venv2docker is run again, so be")
    dockerfile+=("# sure to preserve any edits separately.")
    dockerfile+=(" ")
    dockerfile+=("FROM ${base}")
    if [ ! -z "${maintainer}" ]; then
        dockerfile+=("MAINTAINER ${maintainer}")
    fi
}

# if there are apt commands in $apt then figure out if they
# are package names or a file path and act accordingly
emit_dockerfile_apt_reqs() {
    if [ ! -z "${apt}" ]; then
        dockerfile+=(" ")
        dockerfile+=("# apt dependencies")
        dockerfile+=("RUN apt-get update -y")
        installcmd="RUN apt-get install -y"
        if [[ $apt == "/*" ]]; then
            apt_path=$apt
        else
            apt_path=$projectpath/$apt
        fi
        if [ -f "${apt_path}" ]; then
            echo "Adding apt packages in ${apt_path} ..."
            for package in $(cat ${apt_path}); do
                installcmd=${installcmd}" ${package}"
            done
        else
            echo "Adding apt packages from command line ..."
            apt_split=($(echo ${apt} | tr "," "\n"))
            for package in ${apt_split[@]}; do
                installcmd=${installcmd}" ${package}"
            done
            unset apt_split
        fi
        dockerfile+=("${installcmd}")
        unset apt_path
        unset installcmd
    fi
}

# if there is a pip file path in $pip then copy it into the build
# folder, renaming to `requirements.txt`, and then emit the commands
# to add and install it.
emit_dockerfile_pip_reqs() {
    if [ ! -z "${pip}" ]; then
        if [[ $pip == "/*" ]]; then
            pip_path=$pip
        else
            pip_path=$projectpath/$pip
        fi
        if [ -f "${pip_path}" ]; then
            echo "Adding pip requirements file ${pip_path} ..."
            cp ${pip_path} ${projectpath}/${dockerdir}/requirements.txt
            dockerfile+=(" ")
            dockerfile+=("# pip dependencies")
            dockerfile+=("ADD requirements.txt ${lib_path}${projectdir}")
            dockerfile+=("RUN pip install -qr ${lib_path}${projectdir}/requirements.txt")
            dockerfile+=("RUN rm ${lib_path}${projectdir}/requirements.txt")
        else
            echo "Error: pip requirements file ${pip_path} not found"
            cd ${cwd}
            exit 1
        fi
        unset pip_path
    fi
}

# create the dockerfile commands to migrate and unpack the code
# and dependencies, and in the process save updates to the system
# and python paths
emit_dockerfile_install_commands() {
    echo "Creating project install commands ..."
    dockerfile+=(" ")
    dockerfile+=("# python project and dependencies")
    if [ -f "${projectdir}.tar.gz" ]; then
        echo "Adding ${projectdir}.tar.gz"
        dockerfile+=("COPY ${projectdir}.tar.gz ${bin_path}")
        dockerfile+=("RUN cd ${bin_path} && tar xfz ${projectdir}.tar.gz && rm ${projectdir}.tar.gz")
        sys_paths+=("${bin_path}${projectdir}")
        python_paths+=("${bin_path}${projectdir}")
    fi
    if [ -f "venv_bin.tar.gz" ]; then
        echo "Adding venv_bin.tar.gz"
        dockerfile+=("COPY venv_bin.tar.gz ${lib_path}")
        dockerfile+=("RUN cd ${lib_path} && tar xfz venv_bin.tar.gz && rm venv_bin.tar.gz")
        sys_paths+=("${lib_path}${projectdir}/bin")
    fi
    if [ -f "venv_include.tar.gz" ]; then
        echo "Adding venv_include.tar.gz"
        dockerfile+=("COPY venv_include.tar.gz ${lib_path}")
        dockerfile+=("RUN cd ${lib_path} && tar xfz venv_include.tar.gz && rm venv_include.tar.gz")
    fi
    if [ -f "venv_lib.tar.gz" ]; then
        echo "Adding venv_lib.tar.gz"
        dockerfile+=("COPY venv_lib.tar.gz ${lib_path}")
        dockerfile+=("RUN cd ${lib_path} && tar xfz venv_lib.tar.gz && rm venv_lib.tar.gz")
    fi
    if [ -f "venv_local_lib.tar.gz" ]; then
        echo "Adding venv_local_lib.tar.gz"
        dockerfile+=("COPY venv_local_lib.tar.gz ${lib_path}")
        dockerfile+=("RUN cd ${lib_path} && tar xfz venv_local_lib.tar.gz && rm venv_local_lib.tar.gz")
    fi
}

# create the dockerfile commands to set environment variables in the
# image
emit_dockerfile_env_vars() {
    if [ ! -z "${envs}" ]; then
        echo "Setting environment variables ..."
        dockerfile+=(" ")
        dockerfile+=("# environment variables")
        env_split=($(echo ${envs} | tr "," "\n"))
        for env_pair in ${env_split[@]}; do
           var_split=($(echo ${env_pair} | tr "=" "\n"))
           dockerfile+=("ENV ${var_split[0]} ${var_split[1]}")
        done
        unset env_split
    fi
}

# create the dockerfile commands to expose any ports required
emit_dockerfile_ports() {
    if [ ! -z "${ports}" ]; then
        echo "Exposing ports ..."
        exposecmd="EXPOSE"
        port_split=($(echo ${ports} | tr "," "\n"))
        for port in ${port_split[@]}; do
            exposecmd=${exposecmd}" ${port}"
        done
        unset port_split
        dockerfile+=(" ")
        dockerfile+=("# exposed ports")
        dockerfile+=("${exposecmd}")
    fi
}

# create the commands to set the python and system paths from
# the paths collected during processing (sys_paths and python_paths
# arrays) as well as paths passed on the command line (paths and
# pypaths)
emit_dockerfile_paths() {
    echo "Setting PATH and PYTHONPATH ..."
    dockerfile+=(" ")
    dockerfile+=("# PATH and PYTHONPATH")
    if [ ! -z "${sys_paths[0]}" ] || [ ! -z "${paths}" ]; then
        pathcmd="ENV PATH "
        if [ ! -z "${sys_paths[0]}" ]; then
            for path in ${sys_paths[@]}; do
                pathcmd=${pathcmd}"${path}:"
            done
        fi
        if [ ! -z "${paths}" ]; then
            path_split=($(echo ${paths} | tr "," "\n"))
            for path in ${path_split[@]}; do
                pathcmd=${pathcmd}"${path}:"
            done
            unset path_split
        fi
        pathcmd=${pathcmd}'$PATH'
        dockerfile+=("${pathcmd}")
        unset pathcmd
    fi
    if [ ! -z "${python_paths[0]}" ] || [ ! -z "${pypaths}" ]; then
        pathcmd="ENV PYTHONPATH "
        if [ ! -z "${python_paths[0]}" ]; then
            for path in ${python_paths[@]}; do
                pathcmd=${pathcmd}"${path}:"
            done
        fi
        if [ ! -z "${pypaths}" ]; then
            path_split=($(echo ${pypaths} | tr "," "\n"))
            for path in ${path_split[@]}; do
                pathcmd=${pathcmd}"${path}:"
            done
            unset path_split
        fi
        pathcmd=${pathcmd}'$PYTHONPATH'
        dockerfile+=("${pathcmd}")
        unset pathcmd
    fi
}

# if the caller has passed the -u/--user argument create the
# command to set the user in the image
emit_dockerfile_user() {
    if [ ! -z "${user}" ]; then
        echo "Setting USER ..."
        dockerfile+=(" ")
        dockerfile+=("# set user")
        dockerfile+=("USER ${user}")
    fi
}

# if the caller has passed the -w/--workdir argument create
# the command to set the workdir to the passed value, otherwise
# set it to the project root.
emit_dockerfile_workdir() {
    echo "Setting WORKDIR ..."
    dockerfile+=(" ")
    dockerfile+=("# set working directory")
    setcmd="WORKDIR "
    if [ ! -z "${workdir}" ]; then
        setcmd=${setcmd}${workdir}
    else
        setcmd=${setcmd}${bin_path}${projectdir}
    fi
    dockerfile+=("${setcmd}")
    unset setcmd
}

# create the commands to specify the entrypoint, if any,
# and command line args, if any
emit_dockerfile_entrypoint() {
    if [ ! -z "${entrypoint}" ]; then
        echo "Creating entrypoint..."
        dockerfile+=(" ")
        dockerfile+=("# entrypoint and arguments")
        epcmd="ENTRYPOINT [\"${entrypoint}\""
        if [ ! -z "${args}" ]; then
            args_split=($(echo ${args} | tr "," "\n"))
            for arg in ${args_split[@]}; do
                epcmd=${epcmd}", \"${arg}\""
            done
            unset args_split
        fi
        epcmd=${epcmd}"]"
        dockerfile+=("${epcmd}")
        unset epcmd
    fi
}

# runs the process to generate and write out the dockerfile according
# to the current configuration
emit_dockerfile() {
    echo "Creating dockerfile ..."
    IFS=$'\n'
    emit_dockerfile_header
    emit_dockerfile_apt_reqs
    emit_dockerfile_install_commands
    emit_dockerfile_env_vars
    emit_dockerfile_ports
    emit_dockerfile_paths
    emit_dockerfile_pip_reqs
    emit_dockerfile_user
    emit_dockerfile_workdir
    emit_dockerfile_entrypoint

    if $(echo "# venv2docker generated dockerfile" > ${projectpath}/${dockerdir}/Dockerfile); then
        for line in ${dockerfile[@]}; do
            printf "${line}\n" >> ${projectpath}/${dockerdir}/Dockerfile
        done
        echo "${projectpath}/${dockerdir}/Dockerfile created"
    else
        echo "Error: failed to write ${projectpath}/${dockerdir}/Dockerfile; check file and directory permissions."
        cd ${cwd}
        exit 1
    fi
}

# removes the existing docker image if one exists
remove_existing_image() {
    image=$(docker images -q ${image_name}:${tag})
    if [ ! -z "${image}" ]; then
        echo "Removing existing image ${image}..."
        docker rmi ${image_name}:${tag}
        if [ $? == 0 ]; then
            echo "Image ${image} removed"
        else
            echo "Warning: failed to remove existing image; continuing build"
        fi
    fi
    unset image
}

# executes the docker build command to create the image from the
# generated dockerfile
build_image() {
    if [ "$no_image" = "false" ]; then
        if [ -f "${projectpath}/${dockerdir}/Dockerfile" ]; then
            if [ "$rem_old_image" = "true" ]; then
                remove_existing_image
            fi
            echo "Building docker image ..."
            if [ "$log_build" = "true" ]; then
                docker build --tag=${image_name}:${tag} --rm=true --force-rm=true . | tee build.log
            else
                docker build --tag=${image_name}:${tag} --rm=true --force-rm=true .
            fi
            if [ ${PIPESTATUS[0]} == 0 ]; then
                echo "Image build completed"
            else
                echo "Error: image build failed"
                cd ${cwd}
                exit 1
            fi
        else
            echo "Error: dockerfile not found; exiting build."
            cd ${cwd}
            exit 1
        fi
    fi
}

write_debug_info() {
    echo
    echo "DEBUG ============================="
    echo "image name: ${image_name}"
    echo "tag: ${tag}"
    echo "venv: ${venv}"
    echo "projectpath: ${projectpath}"
    echo "projectdir: ${projectdir}"
    echo "base: ${base}"
    echo "entrypoint: ${entrypoint}"
    echo "args: ${args}"
    echo "no_image: ${no_image}"
    echo "push_image: ${push_image}"
    echo "run_image: ${run_image}"
    echo "rem_old_image: ${rem_old_image}"
    echo "log_build: ${log_build}"
    echo "ports: ${ports}"
    echo "envs: ${envs}"
    echo "dockerdir: ${dockerdir}"
    echo "maintainer: ${maintainer}"
    echo "bin_path: ${bin_path}"
    echo "lib_path: ${lib_path}"
    echo "apt: ${apt}"
    echo "pip: ${pip}"
    echo "paths: ${paths}"
    echo "pypaths: ${pypaths}"
    echo "==================================="
    echo
}

# runs the build process
make_image() {
    # ensure that the image name is set to something reasonable
    if [ -z "${image_name}" ]; then
        venv_split=($(echo ${venv} | tr "/" "\n"))
        image_name=${venv_split[ ${#venv_split[@]} -1 ]}
        unset venv_split
    fi

    setup_build
    echo "Entering directory ${projectpath}/${dockerdir}"
    cd ${projectpath}/${dockerdir}
    emit_dockerfile
    build_image

    if [ "$debug" = "true" ]; then
        write_debug_info
    fi

    cd ${cwd}
}

# set tabs = 4
tabs 4

# parse out the options
OPTS=$(getopt -o b:cde:hn:prst:u:w: --long apt:,args:,base:,bin-path:,clean,command:,debug,dockerdir:,entrypoint:,env:,help,lib-path:,maintainer:,name:,no-dangling,no-log,paths:,pip:,ports:,push,pypaths:,skip-image,tag:,user:,workdir: -- "$@")
if [[ $? -ne 0 ]]; then
    echo "Error: failed to parse command line options."
    exit 1
fi

eval set -- "$OPTS"
while true; do
    case "$1" in
        --apt)
            apt="$2"
            shift; shift
            ;;
        --args)
            args="$2"
            shift; shift
            ;;
        -b|--base)
            base="$2"
            shift; shift
            ;;
        --bin-path)
            bin_path="$2"
            if [[ ${bin_path} != "*/" ]]; then
                bin_path=${bin_path}"/"
            fi
            shift; shift
            ;;
        -c|--clean)
            clean_only=true
            shift
            ;;
        -d|--debug)
            debug=true
            shift
            ;;
        --dockerdir)
            dockerdir="$2"
            shift; shift
            ;;
        --entrypoint)
            entrypoint="$2"
            shift; shift
            ;;
        -e|--env)
            envs="$2"
            shift; shift
            ;;
        -h|--help)
            show_help
            ;;
        --lib-path)
            lib_path="$2"
            if [[ ${lib_path} != "*/" ]]; then
                lib_path=${lib_path}"/"
            fi
            shift; shift
            ;;
        --maintainer)
            maintainer="$2"
            shift; shift
            ;;
        -n|--name)
            image_name="$2"
            shift; shift
            ;;
        --no-dangling)
            rem_old_image=true
            shift
            ;;
        --no-log)
            log_build=false
            shift
            ;;
        --paths)
            paths="$2"
            shift; shift
            ;;
        --pip)
            pip="$2"
            shift; shift
            ;;
        --ports)
            ports="$2"
            shift; shift
            ;;
        -p|--push)
            push_image=true
            shift
            ;;
        --pypaths)
            pypaths="$2"
            shift; shift
            ;;
        -r|--run)
            run_image=true
            shift
            ;;
        -s|--skip-image)
            no_image=true
            shift
            ;;
        -t|--tag)
            tag="$2"
            shift; shift
            ;;
        -u|--user)
            user="$2"
            shift; shift
            ;;
        -w|--workdir)
            workdir="$2"
            shift; shift
            ;;
        --)
            shift
            if [ ! -z "$1" ]; then
                venv="$1"
            fi
            break
            ;;
        *)
            echo "Error: unknown option '${1}'"
            help 1
            ;;
    esac
done

echo
echo "venv2docker ${version}"
echo
ensure_docker
ensure_venv
if [ "$clean_only" = "true" ]; then
    clean_build
else
    make_image
fi
